//
//  TFYUtils.swift
//  TFYSwiftCategoryUtil
//
// Áî∞È£éÊúâ on 2022/5/12.
//

import Foundation
import UIKit
import StoreKit
import SystemConfiguration.CaptiveNetwork
import Combine
import Network
import LocalAuthentication

// MARK: - Êñá‰ª∂Ë∑ØÂæÑÂ∏∏Èáè
public struct FilePath {
    /// ÊñáÊ°£ÁõÆÂΩïË∑ØÂæÑ
    public static let document = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true).last! as NSString
    
    /// ÁºìÂ≠òÁõÆÂΩïË∑ØÂæÑ
    public static let cache = NSSearchPathForDirectoriesInDomains(.cachesDirectory, .userDomainMask, true).last! as NSString
    
    /// ‰∏¥Êó∂ÁõÆÂΩïË∑ØÂæÑ
    public static let temp = NSTemporaryDirectory() as NSString
}

// MARK: - ‰∏ªÂ∑•ÂÖ∑Á±ª
public enum TFYUtils {
    
    // MARK: - Á™óÂè£ÁÆ°ÁêÜ
    public enum Window {
        /// Ëé∑ÂèñÂΩìÂâçÊ¥ªÂä®Á™óÂè£
        public static var current: UIWindow? {
            UIApplication.shared.connectedScenes
                .compactMap { $0 as? UIWindowScene }
                .first { $0.activationState == .foregroundActive }?
                .windows
                .first(where: \.isKeyWindow)
        }
        
        /// Ëé∑ÂèñÈ°∂Â±ÇËßÜÂõæÊéßÂà∂Âô®
        public static var topViewController: UIViewController? {
            guard let window = current else { return nil }
            
            func findTop(from controller: UIViewController?) -> UIViewController? {
                if let nav = controller as? UINavigationController {
                    return findTop(from: nav.visibleViewController)
                }
                if let tab = controller as? UITabBarController {
                    return findTop(from: tab.selectedViewController)
                }
                if let presented = controller?.presentedViewController {
                    return findTop(from: presented)
                }
                return controller
            }
            
            return findTop(from: window.rootViewController)
        }
    }
    
    // MARK: - Â¢ûÂº∫Êó•ÂøóÁ≥ªÁªü
    public enum Logger {
        /// Êó•ÂøóÁ∫ßÂà´
        public enum Level: String, CaseIterable {
            case debug = "üü¢ DEBUG"
            case info = "üîµ INFO"
            case warning = "üü† WARNING"
            case error = "üî¥ ERROR"
        }
        
        /// Êó•ÂøóÈÖçÁΩÆ
        public struct Config {
            public static var maxFileSize: Int = 1024 * 1024 * 5 // 5MB
            public static var maxFiles: Int = 7 // ‰øùÁïô7Â§©
            public static var enabledLevels: Set<Level> = Set(Level.allCases)
        }
        
        /// ÂàÜÁ∫ßÊó•ÂøóËÆ∞ÂΩï
        public static func log(
            _ items: Any...,
            level: Level = .debug,
            file: String = #fileID,
            line: Int = #line,
            function: String = #function
        ) {
            guard Config.enabledLevels.contains(level) else { return }
            
            let content = buildLogContent(items, level: level, file: file, line: line, function: function)
            print(content)
            writeToRotatedFile(content: content)
        }
        
        private static func buildLogContent(
            _ items: [Any],
            level: Level,
            file: String,
            line: Int,
            function: String
        ) -> String {
            let timestamp = Date().ISO8601Format()
            let message = items.map { "\($0)" }.joined(separator: " ")
            return "\(timestamp) \(level.rawValue) [\(file):\(line)] \(function) - \(message)"
        }
        
        private static func writeToRotatedFile(content: String) {
            let fileManager = Foundation.FileManager.default
            let logDir = FilePath.cache.appendingPathComponent("logs")
            
            // ÂàõÂª∫Êó•ÂøóÁõÆÂΩï
            if !fileManager.fileExists(atPath: logDir) {
                try? fileManager.createDirectory(atPath: logDir, withIntermediateDirectories: true)
            }
            
            // ÊåâÊó•ÊúüÂàÜÊñá‰ª∂
            let formatter = Foundation.DateFormatter()
            formatter.dateFormat = "yyyy-MM-dd"
            let filename = "app_\(formatter.string(from: Date())).log"
            let filePath = (logDir as NSString).appendingPathComponent(filename)
            
            // ÂÜôÂÖ•Êñá‰ª∂
            if let data = (content + "\n").data(using: .utf8) {
                if fileManager.fileExists(atPath: filePath) {
                    if let handle = try? FileHandle(forWritingTo: URL(fileURLWithPath: filePath)) {
                        handle.seekToEndOfFile()
                        handle.write(data)
                        try? handle.close()
                    }
                } else {
                    try? data.write(to: URL(fileURLWithPath: filePath))
                }
            }
            
            cleanOldLogs()
        }
        
        private static func cleanOldLogs() {
            let fileManager = Foundation.FileManager.default
            let logDir = FilePath.cache.appendingPathComponent("logs")
            
            guard let files = try? fileManager.contentsOfDirectory(atPath: logDir),
                  files.count > Config.maxFiles else { return }
            
            let sortedFiles = files.sorted()
            let filesToDelete = sortedFiles[0..<(sortedFiles.count - Config.maxFiles)]
            
            filesToDelete.forEach { file in
                let fullPath = (logDir as NSString).appendingPathComponent(file)
                try? fileManager.removeItem(atPath: fullPath)
            }
        }
    }
    
    // MARK: - ÂÜÖË¥≠ÁÆ°ÁêÜ
    public enum IAP {
        public enum PurchaseError: Error, CustomStringConvertible {
            case paymentNotAllowed
            case invalidProduct
            case purchaseFailed(SKError)
            case verificationFailed
            
            public var description: String {
                switch self {
                case .paymentNotAllowed: return "ÊîØ‰ªòÂäüËÉΩ‰∏çÂèØÁî®"
                case .invalidProduct: return "Êó†ÊïàÂïÜÂìÅID"
                case .purchaseFailed(let error): return "Ë¥≠‰π∞Â§±Ë¥•: \(error.localizedDescription)"
                case .verificationFailed: return "Ë¥≠‰π∞È™åËØÅÂ§±Ë¥•"
                }
            }
        }
        
        /// ÂÆâÂÖ®Ë¥≠‰π∞ÊñπÊ≥ï
        public static func purchase(
            productId: String,
            completion: @escaping (Result<Transaction, PurchaseError>) -> Void
        ) {
            guard SKPaymentQueue.canMakePayments() else {
                completion(.failure(.paymentNotAllowed))
                return
            }
            
            Task {
                do {
                    let products = try await Product.products(for: [productId])
                    guard let product = products.first else {
                        completion(.failure(.invalidProduct))
                        return
                    }
                    
                    let result = try await product.purchase()
                    switch result {
                    case .success(let verification):
                        let transaction = try checkVerified(verification)
                        await transaction.finish()
                        completion(.success(transaction))
                    case .pending:
                        throw SKError(.paymentNotAllowed)
                    case .userCancelled:
                        throw SKError(.paymentCancelled)
                    @unknown default:
                        throw SKError(.unknown)
                    }
                } catch let error as SKError {
                    completion(.failure(.purchaseFailed(error)))
                } catch {
                    completion(.failure(.verificationFailed))
                }
            }
        }
        
        private static func checkVerified<T>(_ result: VerificationResult<T>) throws -> T {
            switch result {
            case .unverified:
                throw PurchaseError.verificationFailed
            case .verified(let safe):
                return safe
            }
        }
    }
    
    // MARK: - ÁΩëÁªúÂ∑•ÂÖ∑
    public enum Network {
        public enum Status: CustomStringConvertible {
            case wifi
            case cellular
            case disconnected
            
            public var description: String {
                switch self {
                case .wifi: return "Wi-Fi"
                case .cellular: return "ËúÇÁ™ùÁΩëÁªú"
                case .disconnected: return "Êó†ÁΩëÁªúËøûÊé•"
                }
            }
        }
        
        /// ÂÆûÊó∂ÁΩëÁªúÁä∂ÊÄÅÁõëÊµã
        public static func monitor(handler: @escaping (Status) -> Void) -> NWPathMonitor {
            let monitor = NWPathMonitor()
            let queue = DispatchQueue(label: "com.tfy.network.monitor")
            
            monitor.pathUpdateHandler = { path in
                let status: Status
                switch path.status {
                case .satisfied:
                    status = path.usesInterfaceType(.wifi) ? .wifi : .cellular
                default:
                    status = .disconnected
                }
                DispatchQueue.main.async { handler(status) }
            }
            
            monitor.start(queue: queue)
            return monitor
        }
        
        /// ÂΩìÂâçÁΩëÁªúÁä∂ÊÄÅ
        public static var currentStatus: Status {
            let monitor = NWPathMonitor()
            let semaphore = DispatchSemaphore(value: 0)
            var currentStatus: Status = .disconnected
            
            monitor.pathUpdateHandler = { path in
                switch path.status {
                case .satisfied:
                    currentStatus = path.usesInterfaceType(.wifi) ? .wifi : .cellular
                default:
                    currentStatus = .disconnected
                }
                semaphore.signal()
            }
            
            let queue = DispatchQueue(label: "com.tfy.network.status")
            monitor.start(queue: queue)
            semaphore.wait()
            return currentStatus
        }
    }
    
    // MARK: - Á≥ªÁªüÂäüËÉΩ
    public enum System {
        /// ÂÆâÂÖ®ÊâìÂºÄURL
        public static func openURL(_ urlString: String) async -> Bool {
            guard let url = URL(string: urlString),
                  await UIApplication.shared.canOpenURL(url) else {
                return false
            }
            
            return await UIApplication.shared.open(url)
        }
        
        /// Êã®ÊâìÁîµËØù
        public static func call(_ number: String) async -> Bool {
            let urlString = "tel://\(number)"
            return await openURL(urlString)
        }
        
        /// Ë∑≥ËΩ¨App StoreËØÑÂàÜ
        public static func requestReview() {
            if let scene = UIApplication.shared.connectedScenes.first(where: {
                $0.activationState == .foregroundActive
            }) as? UIWindowScene {
                SKStoreReviewController.requestReview(in: scene)
            }
        }
    }
    
    public enum viewController {
    
            // MARK: - ÂÆπÂô®ÊéßÂà∂Âô®Êü•Êâæ
            /// Ëé∑ÂèñÂΩìÂâçËßÜÂõæÊâÄÂú®ÁöÑÂÆπÂô®ÊéßÂà∂Âô®ÔºàÂ¢ûÂº∫ÁâàÔºâ
            /// - Parameters:
            ///   - types: ‰ºòÂÖàÊü•ÊâæÁöÑÂÆπÂô®Á±ªÂûãÈ°∫Â∫èÔºåÈªòËÆ§ [UINavigationController.self, UITabBarController.self]
            /// - Returns: ÊâæÂà∞ÁöÑÁ¨¨‰∏Ä‰∏™ÂåπÈÖçÁöÑÂÆπÂô®ÊéßÂà∂Âô®
            public static func currentContainer(
                for viewController: UIViewController,
                types: [UIViewController.Type] = [UINavigationController.self, UITabBarController.self]
            ) -> UIViewController? {
                // ‰ºòÂÖàÊ£ÄÊü•Áõ¥Êé•Áà∂Á∫ßÂÖ≥Á≥ª
                for type in types {
                    if let container = findContainer(from: viewController, type: type) {
                        return container
                    }
                }
                // Êâ©Â±ïÊü•ÊâæÂ±ÇÁ∫ß
                return findExtendedContainer(from: viewController, types: types)
            }
            
            /// ÂΩìÂâçÂÆπÂô®ÊéßÂà∂Âô®Ôºà‰æøÊç∑ËÆøÈóÆÔºâ
            public static var currentContainer: UIViewController? {
                guard let currentVC = Window.topViewController else {
                    Logger.log("Êó†Ê≥ïËé∑ÂèñÂΩìÂâçËßÜÂõæÊéßÂà∂Âô®", level: .warning)
                    return nil
                }
                return currentContainer(for: currentVC)
            }
            
            // MARK: - ÁßÅÊúâÊñπÊ≥ï
            private static func currentContainer(for controller: UIViewController) -> UIViewController? {
                currentContainer(for: controller, types: [UINavigationController.self, UITabBarController.self])
            }
            
            private static func findExtendedContainer(
                from source: UIViewController,
                types: [UIViewController.Type]
            ) -> UIViewController? {
                var current: UIViewController? = source
                
                while let controller = current {
                    for type in types {
                        if controller.isKind(of: type) {
                            return controller
                        }
                    }
                    current = getNextParent(for: controller)
                }
                return nil
            }
            
            private static func getNextParent(for controller: UIViewController) -> UIViewController? {
                if let parent = controller.parent { return parent }
                if let presenting = controller.presentingViewController { return presenting }
                if let navParent = controller.navigationController { return navParent }
                if let tabParent = controller.tabBarController { return tabParent }
                return nil
            }
            
            // MARK: - ÂÆπÂô®Êü•Êâæ
            public static func findContainer<T: UIViewController>(
                from source: UIViewController,
                type: T.Type
            ) -> T? {
                if let target = source as? T { return target }
                if let parent = source.parent { return findContainer(from: parent, type: type) }
                if let presented = source.presentedViewController { return findContainer(from: presented, type: type) }
                if let nav = source.navigationController { return findContainer(from: nav, type: type) }
                if let tab = source.tabBarController { return findContainer(from: tab, type: type) }
                return nil
            }
            
            // MARK: - ÊéßÂà∂Âô®Êìç‰Ωú
            /// ÂÖ≥Èó≠ÊéßÂà∂Âô®
            public static func dismiss(_ controller: UIViewController, animated: Bool = true, completion: (() -> Void)? = nil) {
                DispatchQueue.main.async {
                    controller.dismiss(animated: animated, completion: completion)
                }
            }
            
            // MARK: - È°µÈù¢Ë∑≥ËΩ¨
            /// ËøîÂõûÂà∞ÊåáÂÆöÁ±ªÂûãÁöÑÊéßÂà∂Âô®ÁïåÈù¢
            public static func returnTo<T: UIViewController>(
                _ type: T.Type,
                animated: Bool = true,
                inclusive: Bool = false,
                completion: @escaping (Bool) -> Void
            ) {
                guard let currentVC = Window.topViewController else {
                    Logger.log("Êó†Ê≥ïËé∑ÂèñÂΩìÂâçËßÜÂõæÊéßÂà∂Âô®", level: .warning)
                    completion(false)
                    return
                }
                
                guard let targetVC = findTargetViewController(from: currentVC, type: type, inclusive: inclusive) else {
                    Logger.log("Êú™ÊâæÂà∞ \(type) Á±ªÂûãÁöÑÊéßÂà∂Âô®", level: .info)
                    completion(false)
                    return
                }
                
                performNavigation(to: targetVC, from: currentVC, animated: animated, completion: completion)
            }
            
            // MARK: - ÁßÅÊúâÂÆûÁé∞
            private static func findTargetViewController<T: UIViewController>(
                from source: UIViewController,
                type: T.Type,
                inclusive: Bool
            ) -> T? {
                var controllers = [UIViewController]()
                
                if let nav = source.navigationController {
                    controllers = nav.viewControllers
                } else if let presentedChain = getPresentedChain(from: source) {
                    controllers = presentedChain
                }
                
                let matched = controllers.reversed().first { controller in
                    inclusive ? controller.isKind(of: type) : (controller != source && controller.isKind(of: type))
                }
                
                return matched as? T
            }
            
            private static func getPresentedChain(from source: UIViewController) -> [UIViewController]? {
                var chain = [UIViewController]()
                var current: UIViewController? = source
                
                while let controller = current {
                    chain.append(controller)
                    current = controller.presentingViewController
                }
                
                return chain.isEmpty ? nil : chain
            }
            
            private static func performNavigation<T: UIViewController>(
                to target: T,
                from source: UIViewController,
                animated: Bool,
                completion: @escaping (Bool) -> Void
            ) {
                if let nav = source.navigationController, nav.viewControllers.contains(target) {
                    popToViewController(nav: nav, target: target, animated: animated, completion: completion)
                } else if source.presentingViewController != nil {
                    dismissToViewController(source: source, target: target, animated: animated, completion: completion)
                } else {
                    completion(false)
                }
            }
            
            private static func popToViewController<T: UIViewController>(
                nav: UINavigationController,
                target: T,
                animated: Bool,
                completion: @escaping (Bool) -> Void
            ) {
                DispatchQueue.main.async {
                    nav.popToViewController(target, animated: animated) { _ in
                        completion(true)
                    }
                }
            }
            
            private static func dismissToViewController<T: UIViewController>(
                source: UIViewController,
                target: T,
                animated: Bool,
                completion: @escaping (Bool) -> Void
            ) {
                DispatchQueue.main.async {
                    source.dismiss(animated: animated) {
                        completion(true)
                    }
                }
            }
        }
}

// MARK: - Êñ∞Â¢ûËÆæÂ§á‰ø°ÊÅØÊ®°Âùó
public extension TFYUtils {
    
    enum Device {
        /// ËÆæÂ§áÁ±ªÂûãÂà§Êñ≠
        public enum ModelType {
            case iPhone
            case iPad
            case mac
            case carPlay
            case unspecified
        }
        
        /// ÂΩìÂâçËÆæÂ§áÁ±ªÂûã
        public static var modelType: ModelType {
            #if targetEnvironment(macCatalyst)
            return .mac
            #elseif targetEnvironment(simulator)
            return .unspecified
            #else
            switch UIDevice.current.userInterfaceIdiom {
            case .phone: return .iPhone
            case .pad: return .iPad
            case .carPlay: return .carPlay
            default: return .unspecified
            }
            #endif
        }
        
        /// ËÆæÂ§áÂÆâÂÖ®Âå∫Âüü
        public static var safeAreaInsets: UIEdgeInsets {
            Window.current?.safeAreaInsets ?? .zero
        }
        
        /// ËÆæÂ§áÂêçÁß∞
        public static var name: String {
            UIDevice.current.name
        }
        
        /// Á≥ªÁªüÁâàÊú¨
        public static var systemVersion: String {
            UIDevice.current.systemVersion
        }
        
        /// ÊòØÂê¶ÊòØÂàòÊµ∑Â±èËÆæÂ§á
        public static var hasNotch: Bool {
            safeAreaInsets.top > 20
        }
        
        /// Â±èÂπïÂ∞∫ÂØ∏
        public static var screenSize: CGSize {
            UIScreen.main.bounds.size
        }
        
        /// ÁîµÊ±†ÁîµÈáè
        public static var batteryLevel: Float {
            UIDevice.current.isBatteryMonitoringEnabled = true
            return UIDevice.current.batteryLevel
        }
        
        /// ÊòØÂê¶Â§Ñ‰∫é‰ΩéÁîµÈáèÊ®°Âºè
        public static var isLowPowerModeEnabled: Bool {
            ProcessInfo.processInfo.isLowPowerModeEnabled
        }
    }
}

// MARK: - Êñ∞Â¢ûÂÆâÂÖ®Â≠òÂÇ®Ê®°Âùó
public extension TFYUtils {
    enum Keychain {
        /// ÂÆâÂÖ®Â≠òÂÇ®Êï∞ÊçÆ
        public static func save(_ data: Data, service: String, account: String) throws {
            let query = [
                kSecValueData: data,
                kSecClass: kSecClassGenericPassword,
                kSecAttrService: service,
                kSecAttrAccount: account
            ] as CFDictionary
            
            let status = SecItemAdd(query, nil)
            guard status == errSecSuccess else {
                throw KeychainError.unhandledError(status: status)
            }
        }
        
        /// ËØªÂèñÂÆâÂÖ®Êï∞ÊçÆ
        public static func read(service: String, account: String) throws -> Data {
            let query = [
                kSecClass: kSecClassGenericPassword,
                kSecAttrService: service,
                kSecAttrAccount: account,
                kSecReturnData: true
            ] as CFDictionary
            
            var result: AnyObject?
            let status = SecItemCopyMatching(query, &result)
            
            guard status == errSecSuccess else {
                throw KeychainError.unhandledError(status: status)
            }
            
            return result as? Data ?? Data()
        }
        
        public enum KeychainError: Error {
            case unhandledError(status: OSStatus)
        }
    }
}

// MARK: - Êñ∞Â¢ûÂä®ÁîªÊïàÊûúÊ®°Âùó
public extension TFYUtils {
    enum Animation {
        /// ÂºπÊÄßÁº©ÊîæÂä®Áîª
        public static func springScale(
            view: UIView,
            duration: TimeInterval = 0.6,
            scale: CGFloat = 0.95
        ) {
            UIView.animate(
                withDuration: duration,
                delay: 0,
                usingSpringWithDamping: 0.4,
                initialSpringVelocity: 0.2,
                options: [.curveEaseInOut],
                animations: {
                    view.transform = CGAffineTransform(scaleX: scale, y: scale)
                },
                completion: { _ in
                    UIView.animate(withDuration: 0.3) {
                        view.transform = .identity
                    }
                }
            )
        }
        
        /// Ê∏êÈöêËøáÊ∏°
        public static func crossfade(
            view: UIView,
            duration: TimeInterval = 0.3
        ) {
            let transition = CATransition()
            transition.duration = duration
            transition.type = .fade
            view.layer.add(transition, forKey: nil)
        }
    }
}

// MARK: - Êñ∞Â¢ûÊú¨Âú∞ÈÄöÁü•Ê®°Âùó
public extension TFYUtils {
    enum Notification {
        /// ËØ∑Ê±ÇÈÄöÁü•ÊùÉÈôê
        public static func requestAuthorization() async -> Bool {
            do {
                return try await UNUserNotificationCenter.current()
                    .requestAuthorization(options: [.alert, .sound, .badge])
            } catch {
                Logger.log("ÈÄöÁü•ÊùÉÈôêËØ∑Ê±ÇÂ§±Ë¥•: \(error)", level: .error)
                return false
            }
        }
        
        /// ÂèëÈÄÅÊú¨Âú∞ÈÄöÁü•
        public static func schedule(
            title: String,
            body: String,
            interval: TimeInterval = 1.0
        ) async {
            let content = UNMutableNotificationContent()
            content.title = title
            content.body = body
            content.sound = .default
            
            let trigger = UNTimeIntervalNotificationTrigger(
                timeInterval: interval,
                repeats: false
            )
            
            let request = UNNotificationRequest(
                identifier: UUID().uuidString,
                content: content,
                trigger: trigger
            )
            
            do {
                try await UNUserNotificationCenter.current().add(request)
            } catch {
                Logger.log("ÈÄöÁü•ÂèëÈÄÅÂ§±Ë¥•: \(error)", level: .error)
            }
        }
    }
}

// MARK: - Êñ∞Â¢ûËß¶ËßâÂèçÈ¶àÊ®°Âùó
public extension TFYUtils {
    enum Haptics {
        /// Ëß¶ËßâÂèçÈ¶àÁ±ªÂûã
        public enum FeedbackType {
            case success
            case warning
            case error
            case selection
            case impact(style: UIImpactFeedbackGenerator.FeedbackStyle)
        }
        
        /// Ëß¶ÂèëËß¶ËßâÂèçÈ¶à
        public static func generate(_ type: FeedbackType) {
            switch type {
            case .success:
                UINotificationFeedbackGenerator().notificationOccurred(.success)
            case .warning:
                UINotificationFeedbackGenerator().notificationOccurred(.warning)
            case .error:
                UINotificationFeedbackGenerator().notificationOccurred(.error)
            case .selection:
                UISelectionFeedbackGenerator().selectionChanged()
            case .impact(let style):
                UIImpactFeedbackGenerator(style: style).impactOccurred()
            }
        }
    }
}

// MARK: - Êñ∞Â¢ûÁîüÁâ©ËØÜÂà´Ê®°Âùó
public extension TFYUtils {
    enum Biometrics {
        /// ÁîüÁâ©ËØÜÂà´Á±ªÂûã
        public enum BiometricType {
            case none
            case touchID
            case faceID
            
            public var description: String {
                switch self {
                case .none: return "‰∏çÊîØÊåÅ"
                case .touchID: return "Touch ID"
                case .faceID: return "Face ID"
                }
            }
        }
        
        /// Ëé∑ÂèñÂΩìÂâçËÆæÂ§áÊîØÊåÅÁöÑÁîüÁâ©ËØÜÂà´Á±ªÂûã
        public static var biometricType: BiometricType {
            let context = LAContext()
            var error: NSError?
            
            guard context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) else {
                return .none
            }
            
            switch context.biometryType {
            case .touchID:
                return .touchID
            case .faceID:
                return .faceID
            default:
                return .none
            }
        }
        
        /// ÊâßË°åÁîüÁâ©ËØÜÂà´È™åËØÅ
        public static func authenticate(
            reason: String,
            completion: @escaping (Result<Void, Error>) -> Void
        ) {
            let context = LAContext()
            context.evaluatePolicy(
                .deviceOwnerAuthenticationWithBiometrics,
                localizedReason: reason
            ) { success, error in
                DispatchQueue.main.async {
                    if success {
                        completion(.success(()))
                    } else if let error = error {
                        completion(.failure(error))
                    }
                }
            }
        }
    }
}

// MARK: - Êñ∞Â¢ûÊñá‰ª∂Êìç‰ΩúÊ®°Âùó
public extension TFYUtils {
    enum FileManager {
        /// Ëé∑ÂèñÊñá‰ª∂Â§ßÂ∞è
        public static func fileSize(at path: String) -> Int64 {
            guard let attributes = try? Foundation.FileManager.default.attributesOfItem(atPath: path) else {
                return 0
            }
            return attributes[.size] as? Int64 ?? 0
        }
        
        /// Ê†ºÂºèÂåñÊñá‰ª∂Â§ßÂ∞è
        public static func formatFileSize(_ size: Int64) -> String {
            let units = ["B", "KB", "MB", "GB"]
            var size = Double(size)
            var unitIndex = 0
            
            while size >= 1024 && unitIndex < units.count - 1 {
                size /= 1024
                unitIndex += 1
            }
            
            return String(format: "%.2f %@", size, units[unitIndex])
        }
        
        /// ÂàõÂª∫ÁõÆÂΩï
        public static func createDirectory(at path: String) throws {
            try Foundation.FileManager.default.createDirectory(
                atPath: path,
                withIntermediateDirectories: true
            )
        }
        
        /// Âà†Èô§Êñá‰ª∂ÊàñÁõÆÂΩï
        public static func remove(at path: String) throws {
            try Foundation.FileManager.default.removeItem(atPath: path)
        }
    }
}

// MARK: - Êñ∞Â¢ûÂõæÁâáÂ§ÑÁêÜÊ®°Âùó
public extension TFYUtils {
    enum ImageProcessor {
        /// ÂéãÁº©ÂõæÁâá
        public static func compress(
            image: UIImage,
            maxSize: Int = 1024 * 1024  // 1MB
        ) -> Data? {
            var compression: CGFloat = 1.0
            var data = image.jpegData(compressionQuality: compression)
            
            while let currentData = data, currentData.count > maxSize && compression > 0.1 {
                compression -= 0.1
                data = image.jpegData(compressionQuality: compression)
            }
            
            return data
        }
        
        /// Ë∞ÉÊï¥ÂõæÁâáÂ∞∫ÂØ∏
        public static func resize(
            image: UIImage,
            to size: CGSize,
            scale: CGFloat = UIScreen.main.scale
        ) -> UIImage? {
            UIGraphicsBeginImageContextWithOptions(size, false, scale)
            defer { UIGraphicsEndImageContext() }
            
            image.draw(in: CGRect(origin: .zero, size: size))
            return UIGraphicsGetImageFromCurrentImageContext()
        }
        
        /// ÁîüÊàêÂúÜËßíÂõæÁâá
        public static func roundCorners(
            image: UIImage,
            radius: CGFloat
        ) -> UIImage? {
            let rect = CGRect(origin: .zero, size: image.size)
            
            UIGraphicsBeginImageContextWithOptions(image.size, false, image.scale)
            defer { UIGraphicsEndImageContext() }
            
            let context = UIGraphicsGetCurrentContext()
            context?.addPath(UIBezierPath(roundedRect: rect, cornerRadius: radius).cgPath)
            context?.clip()
            
            image.draw(in: rect)
            return UIGraphicsGetImageFromCurrentImageContext()
        }
    }
}

// MARK: - Êñ∞Â¢ûÊó•ÊúüÂ§ÑÁêÜÊ®°Âùó
public extension TFYUtils {
    enum DateUtils {  // ÈáçÂëΩÂêç‰ª•ÈÅøÂÖç‰∏é Foundation.DateFormatter ÂÜ≤Á™Å
        private static let sharedFormatter: Foundation.DateFormatter = {
            let formatter = Foundation.DateFormatter()
            formatter.locale = Locale(identifier: "zh_CN")  // ËÆæÁΩÆ‰∏≠ÊñáÂå∫Âüü
            return formatter
        }()
        
        /// Ê†ºÂºèÂåñÊó•Êúü
        public static func string(
            from date: Date,
            format: String = "yyyy-MM-dd HH:mm:ss"
        ) -> String {
            sharedFormatter.dateFormat = format
            return sharedFormatter.string(from: date)
        }
        
        /// Ëß£ÊûêÊó•ÊúüÂ≠óÁ¨¶‰∏≤
        public static func date(
            from string: String,
            format: String = "yyyy-MM-dd HH:mm:ss"
        ) -> Date? {
            sharedFormatter.dateFormat = format
            return sharedFormatter.date(from: string)
        }
        
        /// Áõ∏ÂØπÊó∂Èó¥ÊèèËø∞
        public static func relativeTimeDescription(from date: Date) -> String {
            let calendar = Calendar.current
            let now = Date()
            let components = calendar.dateComponents([.year, .month, .day, .hour, .minute], from: date, to: now)
            
            if let year = components.year, year > 0 {
                return "\(year)Âπ¥Ââç"
            }
            if let month = components.month, month > 0 {
                return "\(month)‰∏™ÊúàÂâç"
            }
            if let day = components.day, day > 0 {
                return "\(day)Â§©Ââç"
            }
            if let hour = components.hour, hour > 0 {
                return "\(hour)Â∞èÊó∂Ââç"
            }
            if let minute = components.minute, minute > 0 {
                return "\(minute)ÂàÜÈíüÂâç"
            }
            return "ÂàöÂàö"
        }
        
        /// Ëé∑ÂèñÊåáÂÆöÊ†ºÂºèÁöÑÂΩìÂâçÊó∂Èó¥Â≠óÁ¨¶‰∏≤
        public static func currentTimeString(format: String = "yyyy-MM-dd HH:mm:ss") -> String {
            string(from: Date(), format: format)
        }
    }
}

// Êâ©Â±ï UINavigationController ÊîØÊåÅÂ∏¶ completion ÁöÑ pop ÊñπÊ≥ï
extension UINavigationController {
    func popToViewController(
        _ viewController: UIViewController,
        animated: Bool,
        completion: @escaping (Bool) -> Void
    ) {
        popToViewController(viewController, animated: animated)
        
        guard animated, let coordinator = transitionCoordinator else {
            completion(true)
            return
        }
        
        coordinator.animate(alongsideTransition: nil) { _ in
            completion(true)
        }
    }
}

